# Домашнее задание №3

## Цель

Разработать модуль ядра Linux, который реализует структуру данных **стек (Stack)** с использованием встроенных механизмов связных списков ядра (`list.h`). Взаимодействие с модулем должно осуществляться через интерфейс **sysfs**.

Задание развивает навыки работы с:
- структурами данных в ядре Linux
- встроенными макросами и функциями для работы со связными списками
- системой управления памятью в ядре
- интерфейсом **sysfs** для взаимодействия с модулем

---

## Требования к реализации

### 1. Структура данных стека

#### 1.1 Основная структура стека
Необходимо создать структуру для представления стека:

```c
struct stack {
    struct list_head elements;      /* Голова связного списка */
    int size;                       /* Текущее количество элементов */
};
```

#### 1.2 Структура элемента стека
Каждый элемент стека должен содержать:

```c
struct stack_entry {
    struct list_head list;          /* Узел связного списка */
    int data;                       /* Данные (целое число) */
};
```

### 2. Операции над стеком

| Функция | Описание | Возвращаемое значение |
|---------|---------|----------------------|
| `stack_init()` | Инициализация стека | void |
| `stack_push()` | Добавить элемент на вершину стека | int (0 - успех, -1 - ошибка) |
| `stack_pop()` | Удалить и вернуть элемент с вершины | int (значение или код ошибки) |
| `stack_peek()` | Получить значение с вершины без удаления | int (значение или код ошибки) |
| `stack_is_empty()` | Проверить пустоту стека | int (1 - пусто, 0 - не пусто) |
| `stack_size()` | Получить размер стека | int (количество элементов) |
| `stack_clear()` | Очистить стек | void |

### 3. Параметры ядра

| Параметр | Режим | Операция | Формат |
|---------|-------|---------|--------|
| `push` | write | Добавить элемент | Целое число (например: `echo 42 > push`) |
| `pop` | read | Получить и удалить элемент | Целое число из стека или сообщение об ошибке |
| `peek` | read | Получить значение вершины | Целое число из стека или сообщение об ошибке |
| `size` | read | Получить размер стека | Текущее количество элементов |
| `is_empty` | read | Проверить пустоту | "1" (пусто) или "0" (не пусто) |
| `clear` | write | Очистить стек | Любое значение для запуска очистки |

### 4. Требования к безопасности

- ✅ Корректно обрабатывать ошибки выделения памяти (`kmalloc`)
- ✅ Проверять граничные условия (операции над пустым стеком)
- ✅ Освобождать память при удалении модуля

### 5. Обработка ошибок

Определить и документировать коды возврата:

```c
#define STACK_OK          0      /* Операция успешна */
#define STACK_EMPTY      -1      /* Стек пуст */
#define STACK_NOMEM      -2      /* Нет памяти */
#define STACK_INVALID    -3      /* Неверный параметр */
```

---

## Структура проекта

```
kernel_stack_module/
├── Makefile                 # Главный файл сборки
├── src/
│   └── main.c               # Основной код модуля
├── lib/
│   ├── stack.c              # Реализация структуры данных стека
│   ├── stack_ops.c          # Реализация операций со стеком
│   └── inc/
│       ├── stack.h          # Заголовок для функций стека
│       └── stack_ops.h      # Заголовок для операций стека (опционально)
└── inc/
    └── kernel_stack.h       # Заголовок для модуля
```

Модуль должен иметь название `kernel_stack.ko` при сборке.

---

## Пример использования после загрузки модуля

```bash
# Загрузить модуль
sudo insmod kernel_stack.ko

# Добавить элементы
echo 10 > /sys/kernel/kernel_stack/push
echo 20 > /sys/kernel/kernel_stack/push
echo 30 > /sys/kernel/kernel_stack/push

# Проверить размер
cat /sys/kernel/kernel_stack/size
# Вывод: 3

# Получить вершину без удаления
cat /sys/kernel/kernel_stack/peek
# Вывод: 30

# Удалить и получить элемент
cat /sys/kernel/kernel_stack/pop
# Вывод: 30

# Проверить новый размер
cat /sys/kernel/kernel_stack/size
# Вывод: 2

# Проверить пустоту
cat /sys/kernel/kernel_stack/is_empty
# Вывод: 0

# Очистить стек
echo 1 > /sys/kernel/kernel_stack/clear

# Выгрузить модуль
sudo rmmod kernel_stack
```

---

